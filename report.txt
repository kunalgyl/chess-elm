Chess project

No specific build instructions. Just run "elm-make GameApp.elm" or open "GameApp.elm" on the elm-reactor. Tested on Chrome, but seems to work otherwise as well. Changing the zoom level (at least on chrome) can make the buttons go out of position. The controls are pretty self-explanatory, but it is two-player chess. There are two main windows in the game, the actual chess board (which can be interacted with by clicking any piece), and the history viewing window.

All of the rules of chess have been programmed, including piece promotion (to queen), castling (including some of the more subtle castling rules), en-passant capturing, and so on. The game will not allow you to make illegal moves. Higher order functions were used as much as possible to keep this succinct. The main board displays the pieces, as well as a graveyard of captured pieces on the top and bottom respectively.

The game also stores the move history which can be viewed on the window on the right. The window can be interacted with (clicking a move displays the board state after the move was made), and the history of moves can be scrolled through by clicking the moves, using the arrows in the right window, or using the keyboard. Obviously the board cannot be interacted with until the board is brought back to the most recent move (you can use the |=> arrow to jump to this). 

Also stored is the state at the previous move (without some redundant information that can be easily recomputed, like the move history, which is just the tail of the current move history on an undo), so moves can be undone. I could implement this more efficiently by only storing deltas (or allowing moves to be reversed more directly), but this seems sufficient. Other controls include giving player time, (+), starting a new game (eject button), and pausing (pause button).

Another component is the FEN parser. There is a text-box which can take in any fen string and changes the board state to match it. It parses all information from the string (except the move numbers since the 50 move rule is not implemented), including the castling and en-passant information. If an invalid string is presented, it simply defaults to the starting board

The final thing is the AI buttons. These include the (?) button, which is the state of the AI at the moment, and the “Comp” button, which switches the black pieces to playing as an AI (and back). The “?” suggests a move for the current player (after going into a bit of a think). Both use a negamax evaluation strategy (that evaluates the board based on material, threats, and center control), with alpha beta pruning. It is not very good right now, due to only having depth 2, but at the very least tries to defend attacked pieces. I had to introduce delays in the computation time to prevent the game from freezing before even making your move (while it computed) as well as to allow you to revert to a previous state without the ai immediately making a move (otherwise reverting back an exercise in whether you could revert twice before the ai made its move). The final thing is the evolution display, which displays the static evaluation at the given point.